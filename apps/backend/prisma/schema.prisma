// Prisma Schema for Polymarket Telegram Platform
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USERS & AUTHENTICATION
// ============================================

model User {
  id            String   @id @default(uuid())
  telegramId    String   @unique
  username      String?
  firstName     String?
  lastName      String?
  email         String?
  phone         String?
  avatarUrl     String?  @map("avatar_url")
  isActive      Boolean  @default(true) @map("is_active")
  isVerified    Boolean  @default(false) @map("is_verified")
  isBanned      Boolean  @default(false) @map("is_banned")
  bannedUntil   DateTime? @map("banned_until")
  banReason     String?  @map("ban_reason") @db.Text
  lastLoginAt   DateTime? @map("last_login_at")
  riskScore     Decimal  @default(0) @map("risk_score") @db.Decimal(5, 2) // 0-100
  suspiciousFlags Json?  @map("suspicious_flags") // Array of flags: rapid_betting, unusual_amounts, etc.
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  roles         UserRole[]
  wallets       Wallet[]
  bets          Bet[]
  transactions  Transaction[]
  payouts       Payout[]
  markets       Market[] @relation("MarketCreator")
  liquidityPools LiquidityPool[]
  posts         Post[]
  postTemplates PostTemplate[]
  referralLinks ReferralLink[]
  referrerReferrals UserReferral[] @relation("Referrer")
  referredReferrals UserReferral[] @relation("Referred")
  analyticsEvents AnalyticsEvent[]
  adminAuditLogs AdminAuditLog[]
  marketResolutions MarketResolution[] @relation("MarketResolver")
  finalizedResolutions MarketResolution[] @relation("MarketFinalizer")
  createdDisputes MarketDispute[] @relation("DisputeCreator")
  reviewedDisputes MarketDispute[] @relation("DisputeReviewer")
  resolutionAuditLogs ResolutionAuditLog[] @relation("ResolutionAuditPerformer")
  securityEvents SecurityEvent[]
  resolvedSecurityEvents SecurityEvent[] @relation("SecurityEventResolver")
  suspiciousActivities SuspiciousActivity[]
  reviewedSuspiciousActivities SuspiciousActivity[] @relation("SuspiciousActivityReviewer")
  multiAccountClusters MultiAccountCluster[] @relation("MultiAccountConfirmer")
  multiAccountMembers MultiAccountMember[]
  frozenMarkets MarketFreeze[] @relation("MarketFreezer")
  unfrozenMarkets MarketFreeze[] @relation("MarketUnfreezer")

  @@index([telegramId])
  @@index([username])
  @@index([isActive])
  @@index([createdAt])
  @@map("users")
}

model Role {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?  @db.Text
  isSystem    Boolean  @default(false) @map("is_system")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  permissions RolePermission[]
  users       UserRole[]

  @@index([name])
  @@map("roles")
}

model Permission {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?  @db.Text
  resource    String?
  action      String?
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  roles       RolePermission[]

  @@index([name])
  @@index([resource])
  @@map("permissions")
}

model RolePermission {
  roleId       String @map("role_id")
  permissionId String @map("permission_id")

  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
  @@map("role_permissions")
}

model UserRole {
  userId     String   @map("user_id")
  roleId     String   @map("role_id")
  assignedAt DateTime @default(now()) @map("assigned_at")
  assignedBy String?  @map("assigned_by")

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([userId])
  @@index([roleId])
  @@map("user_roles")
}

// ============================================
// WALLETS & BALANCES
// ============================================

model Wallet {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  type       String   // telegram_wallet, ton_wallet, internal
  address    String?
  isActive   Boolean  @default(true) @map("is_active")
  isVerified Boolean  @default(false) @map("is_verified")
  metadata   Json?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relations
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  balances   Balance[]
  bets       Bet[]
  transactions Transaction[]
  payouts    Payout[]

  @@unique([userId, type], where: { isActive: true })
  @@index([userId])
  @@index([type])
  @@index([address])
  @@map("wallets")
}

model Balance {
  id             String   @id @default(uuid())
  walletId       String   @map("wallet_id")
  currency       String   @default("TON")
  amount         Decimal  @default(0) @db.Decimal(20, 8)
  lockedAmount   Decimal  @default(0) @map("locked_amount") @db.Decimal(20, 8)
  availableAmount Decimal @default(0) @map("available_amount") @db.Decimal(20, 8)
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  wallet         Wallet   @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@unique([walletId, currency])
  @@index([walletId])
  @@index([currency])
  @@map("balances")
}

// ============================================
// MARKETS & OUTCOMES
// ============================================

model Category {
  id          String    @id @default(uuid())
  name        String
  slug        String    @unique
  description String?   @db.Text
  iconUrl     String?   @map("icon_url")
  parentId    String?   @map("parent_id")
  sortOrder   Int       @default(0) @map("sort_order")
  isActive    Boolean   @default(true) @map("is_active")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  parent      Category? @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children    Category[] @relation("CategoryHierarchy")
  markets     Market[]

  @@index([slug])
  @@index([parentId])
  @@index([isActive])
  @@map("categories")
}

model Market {
  id                String    @id @default(uuid())
  title             String    @db.VarChar(500)
  slug              String    @unique
  description       String    @db.Text
  categoryId        String?   @map("category_id")
  status            String    @default("draft") // draft, active, locked, resolved, cancelled
  type              String    @default("binary") // binary, multi
  pricingModel      String    @default("lmsr") @map("pricing_model") // lmsr, constant_product
  liquidity         Decimal   @default(0) @db.Decimal(20, 8)
  totalVolume       Decimal   @default(0) @map("total_volume") @db.Decimal(20, 8)
  totalBets         Int       @default(0) @map("total_bets")
  resolvedOutcomeId String?   @map("resolved_outcome_id")
  resolutionDate    DateTime? @map("resolution_date")
  endDate           DateTime? @map("end_date")
  imageUrl          String?   @map("image_url")
  telegramChannelId String?   @map("telegram_channel_id")
  telegramMessageId String?   @map("telegram_message_id")
  createdById       String    @map("created_by_id")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  category          Category? @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  creator           User      @relation("MarketCreator", fields: [createdById], references: [id])
  outcomes          Outcome[]
  liquidityPools    LiquidityPool[]
  bets              Bet[]
  posts             Post[]
  analyticsEvents   AnalyticsEvent[]
  resolution        MarketResolution?
  securityEvents    SecurityEvent[]
  freezes           MarketFreeze[]

  @@index([slug])
  @@index([categoryId])
  @@index([status])
  @@index([createdById])
  @@index([createdAt])
  @@index([endDate])
  @@index([resolutionDate])
  @@index([telegramChannelId])
  @@map("markets")
}

model Outcome {
  id          String   @id @default(uuid())
  marketId    String   @map("market_id")
  title       String
  description String?  @db.Text
  probability Decimal  @default(0.5) @db.Decimal(10, 8)
  shares      Decimal  @default(0) @db.Decimal(20, 8)
  totalVolume Decimal  @default(0) @map("total_volume") @db.Decimal(20, 8)
  isResolved  Boolean  @default(false) @map("is_resolved")
  sortOrder   Int      @default(0) @map("sort_order")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  market      Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)
  liquidityPools LiquidityPool[]
  bets        Bet[]
  resolvedMarkets MarketResolution[] @relation("ResolvedOutcome")
  disputedResolutions MarketDispute[]

  @@index([marketId])
  @@index([isResolved])
  @@index([marketId, isResolved])
  @@map("outcomes")
}

model LiquidityPool {
  id             String   @id @default(uuid())
  marketId       String   @map("market_id")
  outcomeId      String?  @map("outcome_id")
  providerId     String   @map("provider_id")
  amount         Decimal  @db.Decimal(20, 8)
  feeRate       Decimal  @default(0) @map("fee_rate") @db.Decimal(10, 8)
  totalFeesEarned Decimal @default(0) @map("total_fees_earned") @db.Decimal(20, 8)
  isActive       Boolean  @default(true) @map("is_active")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  market         Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)
  outcome        Outcome? @relation(fields: [outcomeId], references: [id], onDelete: SetNull)
  provider       User     @relation(fields: [providerId], references: [id])

  @@index([marketId])
  @@index([outcomeId])
  @@index([providerId])
  @@index([isActive])
  @@map("liquidity_pools")
}

// ============================================
// BETS & TRANSACTIONS
// ============================================

model Bet {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  marketId       String   @map("market_id")
  outcomeId      String   @map("outcome_id")
  walletId       String   @map("wallet_id")
  type           String   // buy, sell
  shares         Decimal  @db.Decimal(20, 8)
  price          Decimal  @db.Decimal(20, 8)
  totalCost      Decimal  @map("total_cost") @db.Decimal(20, 8)
  potentialPayout Decimal? @map("potential_payout") @db.Decimal(20, 8)
  status         String   @default("pending") // pending, active, won, lost, cancelled, refunded
  referralCode   String?  @map("referral_code")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")
  resolvedAt     DateTime? @map("resolved_at")

  // Relations
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  market         Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)
  outcome        Outcome  @relation(fields: [outcomeId], references: [id], onDelete: Cascade)
  wallet         Wallet   @relation(fields: [walletId], references: [id])
  transactions   Transaction[]
  payouts        Payout[]
  userReferrals  UserReferral[]
  analyticsEvents AnalyticsEvent[]
  securityEvents SecurityEvent[]

  @@index([userId])
  @@index([marketId])
  @@index([outcomeId])
  @@index([walletId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, marketId])
  @@index([marketId, status])
  @@map("bets")
}

model Transaction {
  id                  String   @id @default(uuid())
  userId              String   @map("user_id")
  walletId            String   @map("wallet_id")
  betId               String?  @map("bet_id")
  type                String   // deposit, withdrawal, bet_placed, bet_won, bet_lost, refund, commission, referral_bonus, admin_adjustment
  status              String   @default("pending") // pending, completed, failed, cancelled
  amount              Decimal  @db.Decimal(20, 8)
  currency            String   @default("TON")
  fee                 Decimal  @default(0) @db.Decimal(20, 8)
  netAmount           Decimal  @default(0) @map("net_amount") @db.Decimal(20, 8)
  externalTransactionId String? @map("external_transaction_id")
  metadata            Json?
  errorMessage        String?  @map("error_message") @db.Text
  processedAt         DateTime? @map("processed_at")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  wallet              Wallet   @relation(fields: [walletId], references: [id])
  bet                 Bet?     @relation(fields: [betId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([walletId])
  @@index([betId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([externalTransactionId])
  @@index([userId, type])
  @@index([userId, status])
  @@map("transactions")
}

model Payout {
  id                String    @id @default(uuid())
  userId            String    @map("user_id")
  betId             String    @map("bet_id")
  walletId          String    @map("wallet_id")
  amount            Decimal   @db.Decimal(20, 8)
  currency          String    @default("TON")
  status            String    @default("pending") // pending, processing, completed, failed
  transactionId     String?   @map("transaction_id")
  externalPayoutId  String?   @map("external_payout_id")
  processedAt       DateTime? @map("processed_at")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  // Relations
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  bet               Bet       @relation(fields: [betId], references: [id], onDelete: Cascade)
  wallet            Wallet    @relation(fields: [walletId], references: [id])
  transaction       Transaction? @relation(fields: [transactionId], references: [id])

  @@index([userId])
  @@index([betId])
  @@index([walletId])
  @@index([status])
  @@index([transactionId])
  @@index([createdAt])
  @@map("payouts")
}

// ============================================
// TELEGRAM INTEGRATION
// ============================================

model TelegramChannel {
  id              String   @id @default(uuid())
  channelId       String   @unique @map("channel_id")
  channelUsername String?  @map("channel_username")
  channelTitle    String?  @map("channel_title")
  channelType     String?  @map("channel_type")
  isActive        Boolean  @default(true) @map("is_active")
  isVerified      Boolean  @default(false) @map("is_verified")
  subscriberCount Int      @default(0) @map("subscriber_count")
  settings        Json?
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  posts           Post[]

  @@index([channelId])
  @@index([channelUsername])
  @@index([isActive])
  @@map("telegram_channels")
}

model Post {
  id               String    @id @default(uuid())
  channelId        String?   @map("channel_id")
  templateId       String?   @map("template_id")
  marketId         String?   @map("market_id")
  title            String?   @db.VarChar(500)
  content          String    @db.Text
  status           String    @default("draft") // draft, scheduled, published, archived
  scheduledAt      DateTime? @map("scheduled_at")
  publishedAt      DateTime? @map("published_at")
  telegramMessageId String?  @map("telegram_message_id")
  viewsCount       Int       @default(0) @map("views_count")
  clicksCount      Int       @default(0) @map("clicks_count")
  createdById      String    @map("created_by_id")
  createdAt        DateTime  @default(now()) @map("created_at")
  updatedAt        DateTime  @updatedAt @map("updated_at")

  // Relations
  channel          TelegramChannel? @relation(fields: [channelId], references: [id], onDelete: Cascade)
  template         PostTemplate? @relation(fields: [templateId], references: [id])
  market           Market? @relation(fields: [marketId], references: [id], onDelete: SetNull)
  creator          User    @relation(fields: [createdById], references: [id])

  @@index([channelId])
  @@index([templateId])
  @@index([marketId])
  @@index([status])
  @@index([scheduledAt])
  @@index([publishedAt])
  @@index([createdById])
  @@map("posts")
}

model PostTemplate {
  id          String   @id @default(uuid())
  name        String
  description String?  @db.Text
  content     String   @db.Text
  variables   Json?
  isActive    Boolean  @default(true) @map("is_active")
  createdById String   @map("created_by_id")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  creator     User     @relation(fields: [createdById], references: [id])
  posts       Post[]

  @@index([name])
  @@index([isActive])
  @@index([createdById])
  @@map("post_templates")
}

// ============================================
// REFERRAL SYSTEM
// ============================================

model ReferralLink {
  id          String   @id @default(uuid())
  userId      String   @map("user_id")
  code        String   @unique
  name        String?
  description String?  @db.Text
  isActive    Boolean  @default(true) @map("is_active")
  maxUses     Int?     @map("max_uses")
  currentUses Int      @default(0) @map("current_uses")
  bonusRate   Decimal  @default(0) @map("bonus_rate") @db.Decimal(10, 8)
  expiresAt   DateTime? @map("expires_at")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userReferrals UserReferral[]

  @@index([code])
  @@index([userId])
  @@index([isActive])
  @@map("referral_links")
}

model UserReferral {
  id            String   @id @default(uuid())
  referrerId    String   @map("referrer_id")
  referredId    String   @unique @map("referred_id")
  referralLinkId String? @map("referral_link_id")
  firstBetId    String?  @map("first_bet_id")
  totalEarned   Decimal  @default(0) @map("total_earned") @db.Decimal(20, 8)
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  referrer      User     @relation("Referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referred      User     @relation("Referred", fields: [referredId], references: [id], onDelete: Cascade)
  referralLink  ReferralLink? @relation(fields: [referralLinkId], references: [id], onDelete: SetNull)
  firstBet      Bet?     @relation(fields: [firstBetId], references: [id], onDelete: SetNull)

  @@index([referrerId])
  @@index([referredId])
  @@index([referralLinkId])
  @@index([isActive])
  @@map("user_referrals")
}

// ============================================
// ANALYTICS & TRACKING
// ============================================

model TrafficSource {
  id        String   @id @default(uuid())
  name      String
  type      String   // direct, referral, telegram, social, paid
  code      String?  @unique
  isActive  Boolean  @default(true) @map("is_active")
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  analyticsEvents AnalyticsEvent[]

  @@index([code])
  @@index([type])
  @@index([isActive])
  @@map("traffic_sources")
}

model AnalyticsEvent {
  id              String    @id @default(uuid())
  userId          String?   @map("user_id")
  marketId        String?   @map("market_id")
  betId           String?   @map("bet_id")
  eventType       String    @map("event_type")
  metadata        Json?
  ipAddress       String?   @map("ip_address")
  userAgent       String?   @map("user_agent") @db.Text
  referrer        String?   @db.Text
  utmSource       String?   @map("utm_source")
  utmMedium       String?   @map("utm_medium")
  utmCampaign     String?   @map("utm_campaign")
  utmTerm         String?   @map("utm_term")
  utmContent      String?   @map("utm_content")
  referralCode    String?   @map("referral_code")
  trafficSourceId String?   @map("traffic_source_id")
  sessionId       String?   @map("session_id")
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  user            User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  market          Market?   @relation(fields: [marketId], references: [id], onDelete: SetNull)
  bet             Bet?      @relation(fields: [betId], references: [id], onDelete: SetNull)
  trafficSource   TrafficSource? @relation(fields: [trafficSourceId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([marketId])
  @@index([betId])
  @@index([eventType])
  @@index([createdAt])
  @@index([sessionId])
  @@index([referralCode])
  @@index([trafficSourceId])
  @@index([userId, eventType])
  @@index([createdAt, eventType])
  @@map("analytics_events")
}

// ============================================
// ADMIN & AUDIT
// ============================================

model AdminAuditLog {
  id           String   @id @default(uuid())
  adminId      String   @map("admin_id")
  action       String
  resourceType String?  @map("resource_type")
  resourceId   String?  @map("resource_id")
  oldValues    Json?    @map("old_values")
  newValues    Json?    @map("new_values")
  ipAddress    String?  @map("ip_address")
  userAgent    String?  @map("user_agent") @db.Text
  createdAt    DateTime @default(now()) @map("created_at")

  // Relations
  admin        User     @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([action])
  @@index([resourceType, resourceId])
  @@index([createdAt])
  @@index([adminId, action])
  @@map("admin_audit_logs")
}

// ============================================
// MARKET RESOLUTION AUTHORITY
// ============================================

model MarketResolution {
  id                String   @id @default(uuid())
  marketId          String   @unique @map("market_id")
  resolvedOutcomeId String   @map("resolved_outcome_id")
  resolutionSource  String   @default("admin") @map("resolution_source") // admin, oracle
  oracleId          String?  @map("oracle_id")
  resolvedById      String?  @map("resolved_by_id") // admin user ID
  status            String   @default("pending") // pending, confirmed, disputed, final
  resolutionNotes   String?  @map("resolution_notes") @db.Text
  resolutionDate    DateTime @default(now()) @map("resolution_date")
  disputeWindowEnds DateTime? @map("dispute_window_ends")
  finalizedAt       DateTime? @map("finalized_at")
  finalizedById     String?  @map("finalized_by_id")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")

  // Relations
  market            Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)
  resolvedOutcome   Outcome  @relation("ResolvedOutcome", fields: [resolvedOutcomeId], references: [id])
  oracle            Oracle?  @relation(fields: [oracleId], references: [id], onDelete: SetNull)
  resolver          User?    @relation("MarketResolver", fields: [resolvedById], references: [id], onDelete: SetNull)
  finalizer         User?    @relation("MarketFinalizer", fields: [finalizedById], references: [id], onDelete: SetNull)
  disputes          MarketDispute[]
  auditLogs         ResolutionAuditLog[]

  @@index([marketId])
  @@index([status])
  @@index([resolutionSource])
  @@index([oracleId])
  @@index([resolvedById])
  @@index([disputeWindowEnds])
  @@index([createdAt])
  @@map("market_resolutions")
}

model MarketDispute {
  id                String   @id @default(uuid())
  resolutionId      String   @map("resolution_id")
  disputedOutcomeId String   @map("disputed_outcome_id")
  reason            String   @db.Text
  evidence          Json?    // URLs, screenshots, etc.
  status            String   @default("open") // open, reviewed, rejected, accepted
  reviewedById      String?  @map("reviewed_by_id")
  reviewedAt         DateTime? @map("reviewed_at")
  reviewNotes       String?  @map("review_notes") @db.Text
  createdById       String   @map("created_by_id")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  resolution        MarketResolution @relation(fields: [resolutionId], references: [id], onDelete: Cascade)
  disputedOutcome   Outcome          @relation(fields: [disputedOutcomeId], references: [id])
  creator           User            @relation("DisputeCreator", fields: [createdById], references: [id])
  reviewer          User?           @relation("DisputeReviewer", fields: [reviewedById], references: [id], onDelete: SetNull)

  @@index([resolutionId])
  @@index([status])
  @@index([createdById])
  @@index([createdAt])
  @@map("market_disputes")
}

model Oracle {
  id            String   @id @default(uuid())
  name          String
  description   String?  @db.Text
  type          String   // chainlink, band, custom, api
  endpoint      String?  @db.Text
  apiKey        String?  @map("api_key") @db.Text
  isActive      Boolean  @default(true) @map("is_active")
  isVerified    Boolean  @default(false) @map("is_verified")
  metadata      Json?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  resolutions   MarketResolution[]

  @@index([name])
  @@index([type])
  @@index([isActive])
  @@index([isVerified])
  @@map("oracles")
}

model ResolutionAuditLog {
  id              String   @id @default(uuid())
  resolutionId    String   @map("resolution_id")
  action          String   // created, updated, disputed, finalized, cancelled
  performedById   String?  @map("performed_by_id")
  oldValues       Json?
  newValues       Json?
  metadata        Json?
  ipAddress       String?  @map("ip_address")
  userAgent       String?  @map("user_agent") @db.Text
  createdAt       DateTime @default(now()) @map("created_at")

  // Relations
  resolution      MarketResolution @relation(fields: [resolutionId], references: [id], onDelete: Cascade)
  performer       User?           @relation("ResolutionAuditPerformer", fields: [performedById], references: [id], onDelete: SetNull)

  @@index([resolutionId])
  @@index([action])
  @@index([performedById])
  @@index([createdAt])
  @@map("resolution_audit_logs")
}

// ============================================
// SECURITY & ABUSE PREVENTION
// ============================================

model SecurityEvent {
  id              String   @id @default(uuid())
  eventType       String   @map("event_type") // rate_limit_exceeded, suspicious_bet, multi_account, market_freeze, etc.
  severity        String   @default("medium") // low, medium, high, critical
  userId          String?  @map("user_id")
  marketId        String?  @map("market_id")
  betId           String?  @map("bet_id")
  ipAddress       String?  @map("ip_address")
  userAgent       String?  @map("user_agent") @db.Text
  fingerprint     String?  // Browser/device fingerprint
  metadata        Json?
  isResolved      Boolean  @default(false) @map("is_resolved")
  resolvedAt      DateTime? @map("resolved_at")
  resolvedById    String?  @map("resolved_by_id")
  resolutionNotes String?  @map("resolution_notes") @db.Text
  createdAt       DateTime @default(now()) @map("created_at")

  // Relations
  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  market          Market?  @relation(fields: [marketId], references: [id], onDelete: SetNull)
  bet             Bet?      @relation(fields: [betId], references: [id], onDelete: SetNull)
  resolver        User?    @relation("SecurityEventResolver", fields: [resolvedById], references: [id], onDelete: SetNull)

  @@index([eventType])
  @@index([severity])
  @@index([userId])
  @@index([marketId])
  @@index([isResolved])
  @@index([createdAt])
  @@index([ipAddress])
  @@index([fingerprint])
  @@map("security_events")
}

model SuspiciousActivity {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  activityType    String   @map("activity_type") // betting_pattern, velocity, amount, timing
  riskScore       Decimal  @map("risk_score") @db.Decimal(5, 2) // 0-100
  description     String   @db.Text
  metadata        Json?
  isReviewed      Boolean  @default(false) @map("is_reviewed")
  reviewedAt      DateTime? @map("reviewed_at")
  reviewedById    String?  @map("reviewed_by_id")
  reviewDecision  String?  @map("review_decision") // false_positive, confirmed, action_taken
  reviewNotes     String?  @map("review_notes") @db.Text
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewer        User?    @relation("SuspiciousActivityReviewer", fields: [reviewedById], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([activityType])
  @@index([riskScore])
  @@index([isReviewed])
  @@index([createdAt])
  @@map("suspicious_activities")
}

model MultiAccountCluster {
  id              String   @id @default(uuid())
  clusterId       String   @unique @map("cluster_id")
  confidence      Decimal  @map("confidence") @db.Decimal(5, 2) // 0-100
  evidence        Json?    // IP addresses, fingerprints, patterns
  isConfirmed     Boolean  @default(false) @map("is_confirmed")
  confirmedAt     DateTime? @map("confirmed_at")
  confirmedById   String?  @map("confirmed_by_id")
  actionTaken     String?  @map("action_taken") // none, warning, ban, freeze
  notes           String?  @db.Text
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  accounts        MultiAccountMember[]
  confirmer       User?    @relation("MultiAccountConfirmer", fields: [confirmedById], references: [id], onDelete: SetNull)

  @@index([clusterId])
  @@index([confidence])
  @@index([isConfirmed])
  @@index([createdAt])
  @@map("multi_account_clusters")
}

model MultiAccountMember {
  id              String   @id @default(uuid())
  clusterId       String   @map("cluster_id")
  userId          String   @map("user_id")
  evidence        Json?    // Specific evidence linking this user to cluster
  createdAt       DateTime @default(now()) @map("created_at")

  // Relations
  cluster         MultiAccountCluster @relation(fields: [clusterId], references: [id], onDelete: Cascade)
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([clusterId, userId])
  @@index([clusterId])
  @@index([userId])
  @@map("multi_account_members")
}

model MarketFreeze {
  id              String   @id @default(uuid())
  marketId        String   @unique @map("market_id")
  reason          String   @db.Text
  freezeType      String   @map("freeze_type") // emergency, suspicious, maintenance, manual
  severity        String   @default("medium") // low, medium, high, critical
  frozenById      String   @map("frozen_by_id")
  isActive        Boolean  @default(true) @map("is_active")
  unfrozenAt      DateTime? @map("unfrozen_at")
  unfrozenById    String?  @map("unfrozen_by_id")
  unfreezeReason  String?  @map("unfreeze_reason") @db.Text
  metadata        Json?
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  // Relations
  market          Market   @relation(fields: [marketId], references: [id], onDelete: Cascade)
  freezer         User     @relation("MarketFreezer", fields: [frozenById], references: [id])
  unfreezer       User?    @relation("MarketUnfreezer", fields: [unfrozenById], references: [id], onDelete: SetNull)

  @@index([marketId])
  @@index([freezeType])
  @@index([isActive])
  @@index([createdAt])
  @@map("market_freezes")
}
