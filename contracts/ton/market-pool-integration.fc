;; Integration layer between Market Contract and Liquidity Pool
;; This contract acts as a bridge for seamless interaction

#include "imports/stdlib.fc";

;; ============================================
;; Constants
;; ============================================

;; Operation codes
const int OP_PLACE_BET_WITH_POOL = 1;
const int OP_RESOLVE_AND_PAYOUT = 2;

;; ============================================
;; Data Structures
;; ============================================

;; Integration contract data:
;; market_address: address of market contract
;; pool_address: address of liquidity pool contract
;; admin_address: address of admin

(slice, slice, slice) load_integration_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),  ;; market_address
        ds~load_msg_addr(),  ;; pool_address
        ds~load_msg_addr()   ;; admin_address
    );
}

() save_integration_data(slice market_address, slice pool_address, slice admin_address) impure {
    cell c = begin_cell()
        .store_msg_addr(market_address)
        .store_msg_addr(pool_address)
        .store_msg_addr(admin_address)
        .end_cell();
    set_data(c);
}

;; ============================================
;; Main Contract Logic
;; ============================================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore bounced messages
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    ;; Load integration data
    (slice market_address, slice pool_address, slice admin_address) = load_integration_data();
    
    if (op == OP_PLACE_BET_WITH_POOL) {
        ;; Place bet and buy shares from pool in one transaction
        ;; Message format: op (32) | query_id (64) | outcome_id (8) | bet_id (64) | shares_amount (coins)
        
        int outcome_id = in_msg_body~load_uint(8);
        int bet_id = in_msg_body~load_uint(64);
        int shares_amount = in_msg_body~load_coins();
        
        ;; Forward to market contract
        send_msg(
            begin_cell()
                .store_uint(0, 1)
                .store_msg_addr(market_address)
                .store_coins(msg_value)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    begin_cell()
                        .store_uint(1, 32) ;; OP_PLACE_BET
                        .store_uint(query_id, 64)
                        .store_uint(outcome_id, 8)
                        .store_uint(bet_id, 64)
                        .end_cell()
                )
                .end_cell(),
            1
        );
        
        ;; Also buy shares from pool
        send_msg(
            begin_cell()
                .store_uint(0, 1)
                .store_msg_addr(pool_address)
                .store_coins(0) ;; Cost will be calculated by pool
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    begin_cell()
                        .store_uint(3, 32) ;; OP_BUY_SHARES
                        .store_uint(query_id, 64)
                        .store_uint(outcome_id, 8)
                        .store_coins(shares_amount)
                        .end_cell()
                )
                .end_cell(),
            1
        );
        
        return ();
    }
    
    if (op == OP_RESOLVE_AND_PAYOUT) {
        ;; Resolve market and handle payouts through pool
        ;; Message format: op (32) | query_id (64) | winning_outcome (8)
        
        slice sender = cs~load_msg_addr();
        throw_if(100, ~ equal_slices(sender, admin_address));
        
        int winning_outcome = in_msg_body~load_uint(8);
        
        ;; Resolve market
        send_msg(
            begin_cell()
                .store_uint(0, 1)
                .store_msg_addr(market_address)
                .store_coins(0)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(
                    begin_cell()
                        .store_uint(2, 32) ;; OP_RESOLVE_MARKET
                        .store_uint(query_id, 64)
                        .store_uint(winning_outcome, 8)
                        .end_cell()
                )
                .end_cell(),
            1
        );
        
        return ();
    }
    
    throw(999);
}

() recv_external(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    recv_internal(0, msg_value, in_msg_full, in_msg_body);
}

