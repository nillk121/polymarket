;; Market Smart Contract V2 for TON
;; Enhanced version with proper dictionary handling for bets and outcomes

#include "imports/stdlib.fc";

;; ============================================
;; Constants
;; ============================================

;; Operation codes
const int OP_PLACE_BET = 1;
const int OP_RESOLVE_MARKET = 2;
const int OP_WITHDRAW_WINNINGS = 3;
const int OP_CANCEL_MARKET = 4;
const int OP_REFUND_BETS = 5;

;; Market status
const int MARKET_STATUS_ACTIVE = 0;
const int MARKET_STATUS_LOCKED = 1;
const int MARKET_STATUS_RESOLVED = 2;
const int MARKET_STATUS_CANCELLED = 3;

;; Minimum bet amount (in nanoTON)
const int MIN_BET_AMOUNT = 1000000000; ;; 1 TON

;; ============================================
;; Data Structures
;; ============================================

;; Market data structure:
;; outcomes_dict: dictionary mapping outcome_id -> total_amount
;; bets_dict: dictionary mapping (user_address, bet_id) -> (outcome_id, amount, timestamp)
;; status: market status
;; deadline: Unix timestamp
;; resolved_outcome: winning outcome ID (0 if not resolved)
;; total_locked: total locked funds
;; admin_address: address of market admin
;; fee_rate: fee rate in basis points (e.g., 200 = 2%)
;; fee_collector: address to collect fees

(cell, int, int, int, int, slice, int, slice, cell, cell) load_market_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_ref(),  ;; outcomes_dict
        ds~load_uint(8),  ;; status
        ds~load_uint(64),  ;; deadline
        ds~load_uint(8),  ;; resolved_outcome
        ds~load_coins(),  ;; total_locked
        ds~load_msg_addr(),  ;; admin_address
        ds~load_uint(8),  ;; fee_rate
        ds~load_msg_addr(),  ;; fee_collector
        ds~load_ref(),  ;; bets_dict
        ds~load_ref()  ;; outcomes_dict (duplicate for compatibility)
    );
}

() save_market_data(cell outcomes_dict, int status, int deadline, int resolved_outcome, int total_locked, slice admin_address, int fee_rate, slice fee_collector, cell bets_dict) impure {
    cell c = begin_cell()
        .store_ref(outcomes_dict)
        .store_uint(status, 8)
        .store_uint(deadline, 64)
        .store_uint(resolved_outcome, 8)
        .store_coins(total_locked)
        .store_msg_addr(admin_address)
        .store_uint(fee_rate, 8)
        .store_msg_addr(fee_collector)
        .store_ref(bets_dict)
        .store_ref(outcomes_dict)
        .end_cell();
    set_data(c);
}

;; ============================================
;; Helper Functions
;; ============================================

int is_deadline_passed(int deadline) inline {
    return (now() >= deadline);
}

int is_market_active(int status) inline {
    return (status == MARKET_STATUS_ACTIVE);
}

int calculate_fee(int amount, int fee_rate) inline {
    return (amount * fee_rate) / 10000;
}

;; ============================================
;; Main Contract Logic
;; ============================================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore bounced messages
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    ;; Load market data
    (cell outcomes_dict_cell, int status, int deadline, int resolved_outcome, int total_locked, slice admin_address, int fee_rate, slice fee_collector, cell bets_dict, cell outcomes_dict) = load_market_data();
    
    if (op == OP_PLACE_BET) {
        ;; Place bet operation
        ;; Message format: op (32) | query_id (64) | outcome_id (8) | bet_id (64)
        
        ;; Check if market is active
        throw_if(100, ~ is_market_active(status));
        
        ;; Check if deadline has not passed
        throw_if(101, is_deadline_passed(deadline));
        
        int outcome_id = in_msg_body~load_uint(8);
        int bet_id = in_msg_body~load_uint(64);
        
        ;; Check minimum bet amount
        throw_if(102, msg_value < MIN_BET_AMOUNT);
        
        ;; Calculate fee
        int fee = calculate_fee(msg_value, fee_rate);
        int bet_amount = msg_value - fee;
        
        ;; Get sender address
        slice sender = cs~load_msg_addr();
        
        ;; Create bet key: hash of (sender_address, bet_id)
        cell bet_key_cell = begin_cell()
            .store_slice(sender)
            .store_uint(bet_id, 64)
            .end_cell();
        int bet_key = bet_key_cell.hash();
        
        ;; Create bet value: (outcome_id, bet_amount, timestamp)
        cell bet_value = begin_cell()
            .store_uint(outcome_id, 8)
            .store_coins(bet_amount)
            .store_uint(now(), 64)
            .end_cell();
        
        ;; Update bets dictionary
        bets_dict = bets_dict.udict_set_ref(256, bet_key, bet_value);
        
        ;; Update outcomes dictionary (outcome_id -> total_amount)
        int? current_outcome_total = outcomes_dict.udict_get?(8, outcome_id);
        int new_outcome_total = bet_amount;
        if (~ null?(current_outcome_total)) {
            new_outcome_total = current_outcome_total + bet_amount;
        }
        outcomes_dict = outcomes_dict.udict_set_ref(8, outcome_id, begin_cell().store_coins(new_outcome_total).end_cell());
        
        ;; Update total locked
        int new_total_locked = total_locked + bet_amount;
        
        ;; Send fee to fee collector
        if (fee > 0) {
            send_msg(
                begin_cell()
                    .store_uint(0, 1)
                    .store_msg_addr(fee_collector)
                    .store_coins(fee)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_ref(null())
                    .end_cell(),
                1
            );
        }
        
        ;; Save updated market data
        save_market_data(outcomes_dict, status, deadline, resolved_outcome, new_total_locked, admin_address, fee_rate, fee_collector, bets_dict);
        
        return ();
    }
    
    if (op == OP_RESOLVE_MARKET) {
        ;; Resolve market operation
        ;; Message format: op (32) | query_id (64) | outcome_id (8)
        
        ;; Check if sender is admin
        slice sender = cs~load_msg_addr();
        throw_if(200, ~ equal_slices(sender, admin_address));
        
        ;; Check if market is not already resolved/cancelled
        throw_if(201, status == MARKET_STATUS_RESOLVED);
        throw_if(202, status == MARKET_STATUS_CANCELLED);
        
        ;; Check if deadline has passed
        throw_if(203, ~ is_deadline_passed(deadline));
        
        int winning_outcome = in_msg_body~load_uint(8);
        
        ;; Update market status
        save_market_data(outcomes_dict, MARKET_STATUS_RESOLVED, deadline, winning_outcome, total_locked, admin_address, fee_rate, fee_collector, bets_dict);
        
        return ();
    }
    
    if (op == OP_WITHDRAW_WINNINGS) {
        ;; Withdraw winnings operation
        ;; Message format: op (32) | query_id (64) | bet_id (64)
        
        ;; Check if market is resolved
        throw_if(300, status != MARKET_STATUS_RESOLVED);
        throw_if(301, resolved_outcome == 0);
        
        int bet_id = in_msg_body~load_uint(64);
        slice sender = cs~load_msg_addr();
        
        ;; Create bet key
        cell bet_key_cell = begin_cell()
            .store_slice(sender)
            .store_uint(bet_id, 64)
            .end_cell();
        int bet_key = bet_key_cell.hash();
        
        ;; Get bet from dictionary
        cell? bet_value_cell = bets_dict.udict_get_ref?(256, bet_key);
        throw_if(302, null?(bet_value_cell));
        
        slice bet_value = bet_value_cell.begin_parse();
        int bet_outcome = bet_value~load_uint(8);
        int bet_amount = bet_value~load_coins();
        int bet_timestamp = bet_value~load_uint(64);
        
        ;; Check if bet is for winning outcome
        throw_if(303, bet_outcome != resolved_outcome);
        
        ;; Calculate payout (simplified: 1:1 for now, in production use AMM pricing)
        ;; Get total for winning outcome
        int? winning_total = outcomes_dict.udict_get?(8, resolved_outcome);
        throw_if(304, null?(winning_total));
        
        ;; Get total for all outcomes (simplified calculation)
        ;; In production, calculate proper payout based on AMM
        int payout = bet_amount * 2; ;; Simplified 1:1 payout
        
        ;; Check if contract has enough balance
        throw_if(305, my_balance < payout + 10000000); ;; Leave some for fees
        
        ;; Remove bet from dictionary (mark as withdrawn)
        bets_dict = bets_dict.udict_delete?(256, bet_key);
        
        ;; Update total locked
        int new_total_locked = total_locked - bet_amount;
        
        ;; Save updated market data
        save_market_data(outcomes_dict, status, deadline, resolved_outcome, new_total_locked, admin_address, fee_rate, fee_collector, bets_dict);
        
        ;; Send payout
        send_msg(
            begin_cell()
                .store_uint(0, 1)
                .store_slice(sender)
                .store_coins(payout)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(null())
                .end_cell(),
            1
        );
        
        return ();
    }
    
    if (op == OP_CANCEL_MARKET) {
        ;; Cancel market operation
        ;; Message format: op (32) | query_id (64)
        
        ;; Check if sender is admin
        slice sender = cs~load_msg_addr();
        throw_if(400, ~ equal_slices(sender, admin_address));
        
        ;; Check if market is not resolved
        throw_if(401, status == MARKET_STATUS_RESOLVED);
        
        ;; Update market status
        save_market_data(outcomes_dict, MARKET_STATUS_CANCELLED, deadline, 0, total_locked, admin_address, fee_rate, fee_collector, bets_dict);
        
        return ();
    }
    
    if (op == OP_REFUND_BETS) {
        ;; Refund bets operation (for cancelled markets)
        ;; Message format: op (32) | query_id (64) | bet_id (64)
        
        ;; Check if market is cancelled
        throw_if(500, status != MARKET_STATUS_CANCELLED);
        
        int bet_id = in_msg_body~load_uint(64);
        slice sender = cs~load_msg_addr();
        
        ;; Create bet key
        cell bet_key_cell = begin_cell()
            .store_slice(sender)
            .store_uint(bet_id, 64)
            .end_cell();
        int bet_key = bet_key_cell.hash();
        
        ;; Get bet from dictionary
        cell? bet_value_cell = bets_dict.udict_get_ref?(256, bet_key);
        throw_if(501, null?(bet_value_cell));
        
        slice bet_value = bet_value_cell.begin_parse();
        int bet_outcome = bet_value~load_uint(8);
        int bet_amount = bet_value~load_coins();
        int bet_timestamp = bet_value~load_uint(64);
        
        ;; Remove bet from dictionary
        bets_dict = bets_dict.udict_delete?(256, bet_key);
        
        ;; Update total locked
        int new_total_locked = total_locked - bet_amount;
        
        ;; Save updated market data
        save_market_data(outcomes_dict, status, deadline, resolved_outcome, new_total_locked, admin_address, fee_rate, fee_collector, bets_dict);
        
        ;; Refund bet amount
        send_msg(
            begin_cell()
                .store_uint(0, 1)
                .store_slice(sender)
                .store_coins(bet_amount)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_ref(null())
                .end_cell(),
            1
        );
        
        return ();
    }
    
    ;; Unknown operation
    throw(999);
}

() recv_external(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Handle external messages
    recv_internal(0, msg_value, in_msg_full, in_msg_body);
}

;; ============================================
;; Get Methods
;; ============================================

(int, int, int, int, int) get_market_info() method_id {
    (cell outcomes_dict_cell, int status, int deadline, int resolved_outcome, int total_locked, slice admin_address, int fee_rate, slice fee_collector, cell bets_dict, cell outcomes_dict) = load_market_data();
    return (status, deadline, resolved_outcome, total_locked, fee_rate);
}

int can_place_bet() method_id {
    (cell outcomes_dict_cell, int status, int deadline, int resolved_outcome, int total_locked, slice admin_address, int fee_rate, slice fee_collector, cell bets_dict, cell outcomes_dict) = load_market_data();
    if (~ is_market_active(status)) {
        return 0;
    }
    if (is_deadline_passed(deadline)) {
        return 0;
    }
    return 1;
}

int get_total_locked() method_id {
    (cell outcomes_dict_cell, int status, int deadline, int resolved_outcome, int total_locked, slice admin_address, int fee_rate, slice fee_collector, cell bets_dict, cell outcomes_dict) = load_market_data();
    return total_locked;
}

int get_outcome_total(int outcome_id) method_id {
    (cell outcomes_dict_cell, int status, int deadline, int resolved_outcome, int total_locked, slice admin_address, int fee_rate, slice fee_collector, cell bets_dict, cell outcomes_dict) = load_market_data();
    int? outcome_total = outcomes_dict.udict_get?(8, outcome_id);
    if (null?(outcome_total)) {
        return 0;
    }
    return outcome_total;
}

