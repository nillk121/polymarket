;; Market Smart Contract for TON
;; Handles prediction market operations: accept bets, enforce deadlines, lock funds

#include "imports/stdlib.fc";

;; ============================================
;; Constants
;; ============================================

;; Operation codes
const int OP_PLACE_BET = 1;
const int OP_RESOLVE_MARKET = 2;
const int OP_WITHDRAW = 3;
const int OP_CANCEL_MARKET = 4;
const int OP_GET_MARKET_INFO = 5;

;; Market status
const int MARKET_STATUS_ACTIVE = 0;
const int MARKET_STATUS_LOCKED = 1;
const int MARKET_STATUS_RESOLVED = 2;
const int MARKET_STATUS_CANCELLED = 3;

;; Minimum bet amount (in nanoTON)
const int MIN_BET_AMOUNT = 1000000000; ;; 1 TON

;; ============================================
;; Data Structures
;; ============================================

;; Market data stored in contract
;; (int status, int deadline, int resolved_outcome, int total_locked, int admin_address, int fee_rate, cell outcomes_dict)
(slice, int, int, int, int, int, int, cell) load_market_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_ref(),  ;; outcomes_dict
        ds~load_uint(8),  ;; status
        ds~load_uint(64),  ;; deadline (Unix timestamp)
        ds~load_uint(8),  ;; resolved_outcome (0 = not resolved)
        ds~load_coins(),  ;; total_locked
        ds~load_msg_addr(),  ;; admin_address
        ds~load_uint(8),  ;; fee_rate (in basis points, e.g., 200 = 2%)
        ds~load_ref()  ;; outcomes_dict
    );
}

(int, int, int, int, int, int, cell) save_market_data(slice outcomes_dict, int status, int deadline, int resolved_outcome, int total_locked, int admin_address, int fee_rate) impure {
    cell c = begin_cell()
        .store_ref(outcomes_dict)
        .store_uint(status, 8)
        .store_uint(deadline, 64)
        .store_uint(resolved_outcome, 8)
        .store_coins(total_locked)
        .store_msg_addr(admin_address)
        .store_uint(fee_rate, 8)
        .store_ref(outcomes_dict)
        .end_cell();
    set_data(c);
    return (status, deadline, resolved_outcome, total_locked, admin_address, fee_rate, outcomes_dict);
}

;; Bet data structure: (user_address, outcome_id, amount, timestamp)
;; Stored in dictionary: key = (user_address, bet_id), value = (outcome_id, amount, timestamp)

;; ============================================
;; Helper Functions
;; ============================================

;; Check if deadline has passed
int is_deadline_passed(int deadline) inline {
    return (now() >= deadline);
}

;; Check if market is active
int is_market_active(int status) inline {
    return (status == MARKET_STATUS_ACTIVE);
}

;; Calculate fee amount
int calculate_fee(int amount, int fee_rate) inline {
    return (amount * fee_rate) / 10000;
}

;; ============================================
;; Main Contract Logic
;; ============================================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) { ;; ignore bounced messages
        return ();
    }
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    ;; Load market data
    (slice outcomes_dict, int status, int deadline, int resolved_outcome, int total_locked, int admin_address, int fee_rate, cell outcomes_dict_ref) = load_market_data();
    
    if (op == OP_PLACE_BET) {
        ;; Place bet operation
        ;; Message format: op (32) | query_id (64) | outcome_id (8) | bet_id (64)
        
        ;; Check if market is active
        throw_if(100, ~ is_market_active(status));
        
        ;; Check if deadline has not passed
        throw_if(101, is_deadline_passed(deadline));
        
        int outcome_id = in_msg_body~load_uint(8);
        int bet_id = in_msg_body~load_uint(64);
        
        ;; Check minimum bet amount
        throw_if(102, msg_value < MIN_BET_AMOUNT);
        
        ;; Calculate fee
        int fee = calculate_fee(msg_value, fee_rate);
        int bet_amount = msg_value - fee;
        
        ;; Get sender address
        slice sender = cs~load_msg_addr();
        
        ;; Store bet in dictionary
        ;; Key: (sender_address, bet_id)
        ;; Value: (outcome_id, bet_amount, timestamp)
        cell bet_key = begin_cell()
            .store_slice(sender)
            .store_uint(bet_id, 64)
            .end_cell();
        
        cell bet_value = begin_cell()
            .store_uint(outcome_id, 8)
            .store_coins(bet_amount)
            .store_uint(now(), 64)
            .end_cell();
        
        ;; Update outcomes dictionary (simplified - in production use proper dictionary)
        ;; For now, we just update total_locked
        
        int new_total_locked = total_locked + bet_amount;
        
        ;; Save updated market data
        save_market_data(outcomes_dict, status, deadline, resolved_outcome, new_total_locked, admin_address, fee_rate);
        
        ;; Send confirmation message back (optional)
        return ();
    }
    
    if (op == OP_RESOLVE_MARKET) {
        ;; Resolve market operation
        ;; Message format: op (32) | query_id (64) | outcome_id (8)
        
        ;; Check if sender is admin
        slice sender = cs~load_msg_addr();
        throw_if(200, ~ equal_slices(sender, admin_address));
        
        ;; Check if market is not already resolved
        throw_if(201, status == MARKET_STATUS_RESOLVED);
        throw_if(202, status == MARKET_STATUS_CANCELLED);
        
        int winning_outcome = in_msg_body~load_uint(8);
        
        ;; Update market status
        save_market_data(outcomes_dict, MARKET_STATUS_RESOLVED, deadline, winning_outcome, total_locked, admin_address, fee_rate);
        
        return ();
    }
    
    if (op == OP_WITHDRAW) {
        ;; Withdraw funds operation (for winners after resolution)
        ;; Message format: op (32) | query_id (64) | bet_id (64)
        
        ;; Check if market is resolved
        throw_if(300, status != MARKET_STATUS_RESOLVED);
        throw_if(301, resolved_outcome == 0);
        
        int bet_id = in_msg_body~load_uint(64);
        slice sender = cs~load_msg_addr();
        
        ;; In production, check bet dictionary and verify outcome
        ;; For now, simplified version - admin can withdraw all funds
        ;; TODO: Implement proper bet lookup and payout calculation
        
        ;; Check if sender is admin (for now)
        throw_if(302, ~ equal_slices(sender, admin_address));
        
        ;; Send funds back (in production, calculate based on winning bets)
        int withdraw_amount = my_balance - 10000000; ;; Leave some for fees
        send_msg(
            begin_cell()
                .store_uint(0, 1) ;; no bounce
                .store_slice(sender)
                .store_coins(withdraw_amount)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message
                .store_ref(null())
                .end_cell(),
            1
        );
        
        return ();
    }
    
    if (op == OP_CANCEL_MARKET) {
        ;; Cancel market operation
        ;; Message format: op (32) | query_id (64)
        
        ;; Check if sender is admin
        slice sender = cs~load_msg_addr();
        throw_if(400, ~ equal_slices(sender, admin_address));
        
        ;; Check if market is not resolved
        throw_if(401, status == MARKET_STATUS_RESOLVED);
        
        ;; Update market status
        save_market_data(outcomes_dict, MARKET_STATUS_CANCELLED, deadline, 0, total_locked, admin_address, fee_rate);
        
        return ();
    }
    
    if (op == OP_GET_MARKET_INFO) {
        ;; Get market info operation
        ;; Message format: op (32) | query_id (64)
        
        slice sender = cs~load_msg_addr();
        
        ;; Send market info back
        send_msg(
            begin_cell()
                .store_uint(0, 1) ;; no bounce
                .store_slice(sender)
                .store_coins(0)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message
                .store_ref(
                    begin_cell()
                        .store_uint(query_id, 64)
                        .store_uint(status, 8)
                        .store_uint(deadline, 64)
                        .store_uint(resolved_outcome, 8)
                        .store_coins(total_locked)
                        .store_uint(fee_rate, 8)
                        .end_cell()
                )
                .end_cell(),
            1
        );
        
        return ();
    }
    
    ;; Unknown operation
    throw(999);
}

() recv_external(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Handle external messages (from users)
    recv_internal(0, msg_value, in_msg_full, in_msg_body);
}

;; Get method for reading market data
(int, int, int, int, int, int) get_market_info() method_id {
    (slice outcomes_dict, int status, int deadline, int resolved_outcome, int total_locked, int admin_address, int fee_rate, cell outcomes_dict_ref) = load_market_data();
    return (status, deadline, resolved_outcome, total_locked, fee_rate, 0);
}

;; Get method for checking if bet can be placed
int can_place_bet() method_id {
    (slice outcomes_dict, int status, int deadline, int resolved_outcome, int total_locked, int admin_address, int fee_rate, cell outcomes_dict_ref) = load_market_data();
    if (~ is_market_active(status)) {
        return 0;
    }
    if (is_deadline_passed(deadline)) {
        return 0;
    }
    return 1;
}

;; Get method for getting total locked funds
int get_total_locked() method_id {
    (slice outcomes_dict, int status, int deadline, int resolved_outcome, int total_locked, int admin_address, int fee_rate, cell outcomes_dict_ref) = load_market_data();
    return total_locked;
}
